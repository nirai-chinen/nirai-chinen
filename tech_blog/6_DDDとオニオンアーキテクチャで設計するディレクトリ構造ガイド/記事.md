# DDDとオニオンアーキテクチャで設計するディレクトリ構造ガイド

## はじめに
DDD（Domain-Driven Design）とオニオンアーキテクチャを、中規模以上のシステムを想定したディレクトリ構造で説明します。


## ディレクトリ構造例
```
src/
├── domain/                                # どこにも依存しないレイヤー
│   └── order/                             # bounded-context
│       ├── order/                         # aggregate: order
│       │   ├── Order.kt
│       │   ├── OrderId.kt
│       │   ├── OrderLine.kt
│       │   ├── OrderStatus.kt
│       │   └── OrderRepository.kt         # 永続化用ポート(interface)
│       └── payment/                       # aggregate: payment
│           ├── Payment.kt
│           ├── PaymentId.kt
│           ├── PaymentMethod.kt
│           ├── PaymentRepository.kt
│           └── PaymentGateway.kt          # 外部決済APIへのポート
│
├── application/                           # domain のみ依存してよい
│   └── order/
│       ├── order/
│       │   ├── PlaceOrderUseCase.kt
│       │   └── CancelOrderUseCase.kt
│       └── payment/
│           ├── CapturePaymentUseCase.kt
│           └── RefundPaymentUseCase.kt
│
├── infrastructure/                        # domain と application のみ依存してよい
│   └── order/
│       ├── order/
│       │   ├── JpaOrderRepository.kt
│       │   ├── OrderEntity.kt
│       │   └── OrderJpaMapper.kt
│       └── payment/
│           ├── JpaPaymentRepository.kt
│           ├── PaymentEntity.kt
│           ├── PaymentJpaMapper.kt
│           └── ExternalPaymentClient.kt   # PaymentGateway の実装
│
└── presentation/                          # application のみ依存してよい
    └── order/
        ├── order/
        │   ├── OrderController.kt
        │   ├── PlaceOrderRequest.kt
        │   └── PlaceOrderResponse.kt
        └── payment/
            ├── PaymentController.kt
            ├── CapturePaymentRequest.kt
            └── CapturePaymentResponse.kt
```

## ディレクトリ構造の方針
- 最上位はオニオンアーキテクチャのレイヤーごと
  - Gradle などでマルチプロジェクトにすると依存関係をコンパイルレベルで制御しやすい
- 各レイヤー配下は境界付けられたコンテキスト(bounded-context)別に分割してさらに集約(aggregate)で分割する
  - このようにすることで凝集性が高まり、修正範囲の把握がしやすく保守性が高まる
  - 将来モジュラーモノリス → マイクロサービス化するときの切り出し単位にもなりやすい
  - マイクロサービスにするときは多くの場合bounded-contextをベースとして分割するため、その時にはbounded-contextの階層をなくしてdomain/<aggregate>のようにする

## レイヤーごとの責務

### domain/<bounded-context>/<aggregate>
ビジネスルールや概念モデルを外部要因から隔離し、その本質的な振る舞いを分割統治する。
#### 責務
- エンティティ
  - IDが同じであれば同一
- 値オブジェクト
  - 値が同じであれば同一
- ドメインサービス（やむを得ず使う場合だけ）
  - 乱用禁止。モデルの貧血を招きやすいため、ドメインサービスを作る以外の選択肢がない場合の最終手段
- infrastructureのインターフェース（ドメインが依存するポート）
  - 「永続化」や「イベント発行」といったドメイン的な操作名だけを表現し、実際の技術的な実装詳細は表現しない（S3など技術の用語は使わずstorageなどにする）
  - 技術的な要素とドメインを分離できるためinfrastructureの変更が容易になる
#### 依存関係
どこにも依存しない（言語標準ライブラリなど最低限のみ）。

### application/<bounded-context>/<aggregate>
ユースケースを実行するための手順や流れだけをまとめ、処理の段取り全体を分割統治する。
#### 責務
- ユースケース
  - 「ユーザーが注文した」「予約をキャンセルした」みたいな単一の操作の流れを組み立てる。
- トランザクション境界の定義
  - UseCase は「トランザクション境界」であるという概念だけを持つ
  - 実際のトランザクション開始／終了は AOP やアノテーションを通じて infrastructure で実装する
- DTO（Command / Query / Result）
  - UseCase が受け取る入力・出力を表現するためのモデル。
      - Command：状態が変わる入力（書き込み系）
      - Query：状態が変わらない入力（読み込み系）
      - Result：出力
  - ドメイン知識をpresentationに漏らさないようにするためのもの
  - presentationの知識がdomainに漏もれないようにするのもの

#### 依存関係
domainのみ依存してよい
DI コンテナで domain のインターフェースに infrastructure の実装を紐づける

### infrastructure/<bounded-context>
外部サービスやデータストアとの具体的な外部資源とのやりとりを分割統治する。
技術的要素に集中するためaggregateまで区切らなくてもよさそう
複雑になってきたら aggregate ごとに切ることを検討する。

#### 責務
- Repositoryの実装
  - ORマッパー / SQL / NoSQL といった技術選択はここに閉じ込める
- 外部 API クライアント
  - 例: 外部決済サービス、メール送信サービスなど
- メッセージングとの連携
  - メッセージキューとの送受信
#### 依存関係
domainとapplicationのみ依存してよい

### presentation/<bounded-context>/<aggregate>
ユーザーからの入力とシステム内部の動作を切り離し、入出力の境界を分割統治する。
#### 責務
- Controller / Handler
  - HTTP API, メッセージコンシューマ, CLI などの入口
- Request / Response
  - 入力・出力のフォーマット
- 入力の形式的バリデーション
  - すべてのバリデーションをここでやらないこと
    - presentation：型・フォーマット・必須チェックのみ（HTTPリクエストとして最低限正しいか）
    - application：UseCase の前提条件（存在確認やユースケース上の妥当性）
    - domain：ビジネスルールとしてのバリデーション
- エラーの HTTP へのマッピング
- 認証との連携
  - presentation：API レベルの認可
  - application：UseCaseの実行権限チェック
  - domain：ビジネスルールとしての権限チェック
#### 依存関係
applicationのみ依存してよい

## おわりに
ビジネスの変化にシステムを追随させるには、拡張性や変更容易性が必要です。
そのためには、ビジネスルールと技術的要素をきちんと分離し、どこを変えれば何が影響するかを明確にしておく必要があります。
DDDは、ドメインの変化に耐えられるモデルを作るための方法
オニオンアーキテクチャは、技術的な変化に振り回されないようにレイヤと依存方向を整理する方法
ディレクトリ構造は、それらをチーム全体で共有し、守りやすくするための土台
になると考えています。

改善点などありましたらご指摘歓迎です！

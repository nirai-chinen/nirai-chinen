# MCP ServerはBFFのように「Backend for MCP（BFMCP）」として設計しよう

## 前提

以下のような条件の**どちらか**を満たすプロダクトを想定している。

* 中規模以上のプロダクト
* UI / API 向けのバックエンドも提供する

#### 対象外のケース

* 外部サービス単体の API を、そのまま MCP ツールとして公開するケース
  （例: Google Drive / Slack / Notion など）

これらは「Backend for MCP」というより、
**外部 API 用の MCP ラッパー**として別の設計指針が適切である。


## MCPの責務を整理する

まず、MCPが担う責務を整理する。

MCPは本質的に、LLMと外部世界の間に立つ「契約」であり、以下のような役割を持つ。

* 利用可能なツール・リソースの定義
* 入力・出力スキーマの明示
* 実行可能な操作の制限
* LLMからのリクエストの検証
* 実行結果の正規化・返却

重要なのは、**これらはすべてアプリケーションロジックではなく、境界層の責務**だという点だ。

## よくあるアンチパターン

MCP導入初期に陥りがちな構成として、次のようなものがある。

* 既存のバックエンドAPIをそのままMCPツールとして公開
* 各ツールが個別にDBや外部APIへアクセス
* 認可・検証ロジックがツールごとに分散

この構成では、

* セキュリティポリシーが散らばる
* LLM向けの制約と通常API向けの制約が混在する
* MCP特有の仕様変更に追従しづらい

という問題が起きやすい。

## Backend for MCP という考え方

そこで提案したいのが、

> **MCPサーバーを「Backend for MCP」として独立させる**

という設計である。

これは、MCPサーバーを以下のように位置づける。

* 通常のアプリケーションバックエンドとは別レイヤー
* LLM専用のインターフェースを提供
* MCPの責務を一箇所に集約

構成イメージとしては次の通り。

```
LLM
  ↓ (MCP)
MCP Server（Backend for MCP）
  ↓
既存バックエンド / DB / 外部API
```

## MCPサーバーに集約すべき責務

### 1. ツール・リソース定義の集中管理

* どのツールをLLMに公開するか
* どの引数を許可するか
* どの操作は危険なので除外するか

これらをMCPサーバーに集約することで、
「LLMに何をさせてよいか」が一目で分かる。

### 2. バリデーションとガードレール

* スキーマ検証
* レート制限
* 読み取り専用制約
* 組織・ユーザー単位の権限制御

LLMは賢いが、信用はできない。
**ガードレールは必ずサーバー側に置く**のが基本である。

### 3. 実行ロジックの薄いラッピング

MCPサーバー自身は、重い業務ロジックを持つ必要はない。

* 既存APIの呼び出し
* クエリの組み立て
* 結果の整形

といった「翻訳レイヤー」に徹することで、
既存システムとの結合度を下げられる。

## まとめ

MCPサーバーは、

* ただのツール実行基盤ではなく
* MCPの責務を集約した
* **LLM専用の Backend**

として設計するのが自然である。

Backend for Frontend（BFF）が
UIごとに最適化されたバックエンドを提供するように、

> **Backend for MCP は、LLMのための最適な窓口**

になる。
